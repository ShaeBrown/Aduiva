<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_goblin_up</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Create variables, set sprites
h=100;

sprite[0] = spr_goblin_right;
sprite[1] = spr_goblin_right_up;
sprite[2] = spr_goblin_up;
sprite[3] = spr_goblin_left_up;
sprite[4] = spr_goblin_left;
sprite[5] = spr_goblin_left_down;
sprite[6] = spr_goblin_down;
sprite[7] = spr_goblin_down_right;

attack[0] = spr_goblin_attack_right;
attack[1] = spr_goblin_attack_right_up;
attack[2] = spr_goblin_attack_up;
attack[3] = spr_goblin_attack_left_up;
attack[4] = spr_goblin_attack_left;
attack[5] = spr_goblin_attack_left_down;
attack[6] = spr_goblin_attack_down;
attack[7] = spr_goblin_attack_right_down;

die[0] = spr_goblin_die_right;
die[1] = spr_goblin_die_right_up;
die[2] = spr_goblin_die_up;
die[3] = spr_goblin_die_left_up;
die[4] = spr_goblin_die_left;
die[5] = spr_goblin_die_left_down;
die[6] = spr_goblin_die_down;
die[7] = spr_goblin_die_right_down;

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Create path
returnpath=path_add();
grouppath=path_add();
finalpath=path_add();
if global.groupsize=0 {
global.path=global.paths[irandom(array_length_1d(global.paths)-1)]
grouppath=global.path
} 

else {
grouppath=global.path
}
grid=-1;
rot=true;
path_wall=path_add();
attackpath=path_add();
current_path="grouppath"
blocked=true;
done=false;
mypath=path_add();
pos1=1; //This holds the next point on the global path to move to...
x1=path_get_point_x(grouppath,pos1); //This gets the x/y coords of the next point...
y1=path_get_point_y(grouppath,pos1);
mp_grid_path(global.grid,mypath,x,y,x1,y1,true); //Create the short path...
pos2=1;
x2=path_get_point_x(mypath,pos2); //This gets the x/y coords of the next point on the short path...
y2=path_get_point_y(mypath,pos2);

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>
if path_exists(mypath) {
    path_delete(mypath);
    
}
if path_exists(grouppath) {
    path_delete(grouppath);

}
if path_exists(attackpath) {
    path_delete(attackpath);

}
if grid=-1 {
    mp_grid_destroy(grid);

}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="3">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Crystal hit
var xx, yy;
xx = x + lengthdir_x(10, direction);
yy = y + lengthdir_y(10, direction);
sparks_crystal(xx,yy);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Hit wood
var xx, yy;
xx = x + lengthdir_x(15, direction);
yy = y + lengthdir_y(15, direction);
sparks(xx,yy);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Sprites, collisions


var xxx, yyy;
    xxx = x + lengthdir_x(5, direction);
    yyy = y + lengthdir_y(5, direction);


    if collision_circle(x,y,20,obj_enemy_parent,0,1) {
        path_position=path_positionprevious;
        path_end();
        if path_exists(attackpath) {
            path_delete(attackpath);
        }
        var op;
        op=instance_nearest(x,y,obj_enemy_parent);
        if op.h&gt;0 {
            op.h--;
        }
        sprite_index=attack[round(direction / 45) mod 8];
        image_speed=0.2;
        direction=point_direction(x,y,op.x,op.y);
    }

    else if collision_circle(xxx,yyy,5,obj_wall,false,true) {
         sprite_index=attack[round(direction / 45) mod 8];
         image_speed=0.5;
    }
    else if collision_circle(xxx,yyy,5,obj_crystal,false,true) {
         sprite_index=attack[round(direction / 45) mod 8];
         image_speed=0.5;
         if obj_crystal.h&gt;0 {
         obj_crystal.h--;
         }
         if alarm[3]=-1 {
            alarm[3]=10;
         }
    }
    
else {
        if rot=true {
        sprite_index=sprite[round(direction / 45) mod 8];
        }
        image_speed=0.5;
}
    
    
   if h=0 {
    sprite_index=die[round(direction / 45) mod 8];
    if image_index&gt;image_number-1 {
        instance_destroy();
        }
    }


    

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Pathfinding
var arce,xx,yy,inst,arcw,xxx,yyy,
xxx = x + lengthdir_x(5, direction);
yyy = y + lengthdir_y(5, direction);
arce=arc_of_sight(x,y,direction,200,90,obj_enemy_parent,obj_solid);

if done=false {
    arcw=arc_of_sight(x,y,direction,200,90,obj_wall,obj_solid);
}
if path_exists(grouppath) {
    if current_path="grouppath"  {         
        if point_distance(x,y,x1,y1)&lt;12 {
            pos1+=1;
            if pos1=path_get_number(grouppath) {
                    done=true;
                    image_speed=0;
                    }
                
            
            else {
             //The enemy hasn't reached the end so we calculate the x/y coords
             //of the next point on the group path
                    x1=path_get_point_x(grouppath,pos1);
                    y1=path_get_point_y(grouppath,pos1);
            }
        }

            //Now we will deal with the short path
            if point_distance(x,y,x2,y2)&lt;12 {
                //If you are close, advance one point on the path
                pos2+=1;
                if pos2=path_get_number(mypath) {
                    //If we are at the path end, create a new short
                    //path to the next point on the group path
                    mp_grid_path(global.grid,mypath,x,y,x1,y1,true);
                    pos2=1;
                    x2=path_get_point_x(mypath,pos2); //This gets the x/y coords of the next point on the short path
                    y2=path_get_point_y(mypath,pos2);
                    path_set_kind(mypath,1); //Sets the path to allow diagonals
                    path_set_precision(mypath,8); //Sets the path to curve
                }
            }
            if collision_circle(xxx,yyy,5,obj_enemy,true,true)  {
                if path_exists(grouppath) {
                path_position=path_positionprevious;
                direction+=10;
                rot=false;
                image_speed=0;
                }
               
            }
            else{
                if rot=false {
                    rot=true
                }
                mp_potential_step(x2,y2,1,false);
                if path_exists(grouppath) {
                    image_speed=1;
                }
            }
    }
}
if done=true {
    if current_path!="finalpath" {
        if !path_exists(finalpath) {
            finalpath=path_add();
        }
        if mp_grid_path(global.grid,finalpath,x,y,obj_crystal.x,obj_crystal.y,1) {
            if path_exists(attackpath) {
                path_delete(attackpath);
        }
         if path_exists(path_wall) {
            path_delete(path_wall);
        }
        blocked=false;
        current_path="finalpath"
    }
    else {
        direction=point_direction(x,y,obj_crystal.x,obj_crystal.y);
        blocked=true;
        if path_exists(finalpath) {
            path_delete(finalpath);
        }
    }
    }
}

if current_path="finalpath" {
    if grid=-1 {
        grid=mp_grid_create(0,0,room_width/16,room_height/16,16,16); //create grid
    }
    else {
        if path_exists(attackpath) {
            path_delete(attackpath);
        }
        
         if path_exists(path_wall) {
            path_delete(path_wall);
        }
        mp_grid_clear_all(grid); 
        var near1,near2,near3;
        near1=instance_nth_nearest(x,y,obj_enemy,2);
        mp_grid_add_instances(grid,near1,1);
        mp_grid_add_instances(grid,obj_solid,1);
        mp_grid_add_instances(grid,obj_wall,1);
        if !path_exists(finalpath) {
            finalpath=path_add();
        }
        fx = x + lengthdir_x(10, direction);
        fy = y + lengthdir_y(10, direction);
        if !collision_circle(fx,fy,10,obj_enemy,true,true) {
         if mp_grid_path(grid,finalpath,x,y,obj_crystal.x,obj_crystal.y,1) {
            rot=true;
            mp_grid_path(grid,finalpath,x,y,obj_crystal.x,obj_crystal.y,1)
            }
            else {
                blocked=true;
            }
            path_start(finalpath,1.5,0,1);
            current_path="finalpath"
        }
        else {
            path_end();
            if path_exists(finalpath) {
                path_delete(finalpath) 
            }
            sprite_index=attack[round(direction / 45) mod 8];
            image_speed=0.5;
            rot=false;
            if grid!=-1 {
                mp_grid_destroy(grid);
                grid=-1
            }
        }
    }
}

if blocked=true {
        if done=true {
            if path_exists(finalpath) {
                path_delete(finalpath);
            } 

        if arce!=noone {
            current_path="attackpath";
            ddx=arce.x;
            ddy=arce.y;
        if !path_exists(attackpath) {
            attackpath=path_add();
        }
        if grid=-1 {
            grid=mp_grid_create(0,0,room_width/16,room_height/16,16,16); //create grid
        }
        else { 
            mp_grid_clear_all(grid);
            near1=instance_nth_nearest(x,y,obj_enemy,2);
            mp_grid_add_instances(grid,near1,1);
            mp_grid_add_instances(grid,obj_solid,1);

            direction=point_direction(x,y,ddx,ddy);
            if  !collision_circle(x,y,20,obj_enemy_parent,0,0) {
                mp_grid_path(grid,attackpath,x,y,ddx,ddy,1);
                path_start(attackpath,1.5,"",1);
                rot=true;
            }
        }
    }

    else {
      if path_exists(finalpath) {
            path_delete(finalpath);
        }
        if path_exists(attackpath) {
            path_delete(attackpath);
        }
        if !path_exists(path_wall) {
            path_wall=path_add()
        }
        if grid=-1 {
            grid=mp_grid_create(0,0,room_width/16,room_height/16,16,16);
        }
        mp_grid_clear_all(grid); 
        mp_grid_add_instances(grid,obj_solid,1);
        var near;
        near=instance_nth_nearest(x,y,obj_enemy,2);
        mp_grid_add_instances(grid,near,1);
        inst=instance_nearest(x,y,obj_wall)
        if !collision_circle(xxx,yyy,5,obj_wall,false,true) {
            mp_grid_path(grid,path_wall,x,y,inst.x,inst.y,1);
            path_start(path_wall,1,0,1);
            current_path="path_wall";
            rot=true;
        } 
        else {
            path_end();
            direction=point_direction(x,y,inst.x,inst.y)
            if inst.h&gt;0 {
                inst.h--;
            }
            if alarm[1]=-1 {
                alarm[1]=30;
            }
        }               
    }
}
}

if done=false {
    if arce!=noone {
        current_path="attackpath";
        ddx=arce.x;
        ddy=arce.y;
        if !path_exists(attackpath) {
            attackpath=path_add();
        }
        if grid=-1 {
            grid=mp_grid_create(0,0,room_width/16,room_height/16,16,16); //create grid
        }
        else { 
            mp_grid_clear_all(grid);
            var near1,near2;
            near1=instance_nth_nearest(x,y,obj_enemy,2);
            //near2=instance_nth_nearest(x,y,obj_enemy,3);
            //near3=instance_nth_nearest(x,y,obj_enemy,4);
            mp_grid_add_instances(grid,near1,1);
            //mp_grid_add_instances(grid,near2,1);
            //mp_grid_add_instances(grid,near3,1)
            mp_grid_add_instances(grid,obj_solid,1);
     

            direction=point_direction(x,y,ddx,ddy);
            if  !collision_circle(x,y,20,obj_enemy_parent,0,0) {
                mp_grid_path(grid,attackpath,x,y,ddx,ddy,1);
                path_start(attackpath,1.5,"",1);
                rot=true;
            }
        }
    }
    else {
        if current_path="attackpath" {
            pos1=path_get_closest_point(x,y,grouppath,obj_solid,global.grid);
            x1=path_get_point_x(grouppath,pos1);
            y1=path_get_point_y(grouppath,pos1);
            if path_exists(attackpath) {
            path_delete(attackpath);   
            }
            if grid!=-1 {
                mp_grid_destroy(grid)
                grid=-1;
            }
            mp_grid_path(global.grid,mypath,x,y,x1,y1,true);
            pos2=1;
            x2=path_get_point_x(mypath,pos2); //This gets the x/y coords of the next point on the short path
            y2=path_get_point_y(mypath,pos2);
            current_path="grouppath"
        }
    }
if arcw!=noone {
        if grid=-1 {
            grid=mp_grid_create(0,0,room_width/16,room_height/16,16,16);
        }
        if !path_exists(path_wall) {
            path_wall=path_add();
        }
        mp_grid_clear_all(grid); 
        mp_grid_add_instances(grid,obj_solid,1);
        var near;
        near=instance_nth_nearest(x,y,obj_enemy,2);
        mp_grid_add_instances(grid,near,1);
        if !collision_circle(xxx,yyy,5,obj_wall,true,true) {
            mp_grid_path(grid,path_wall,x,y,arcw.x,arcw.y,1);
            path_start(path_wall,1,0,1);
            current_path="path_wall";
            rot=true;
        } 
        else  {
                path_end();
                inst=instance_nearest(x,y,obj_wall);
                direction=point_direction(x,y,inst.x,inst.y)
                  if inst.h&gt;0 {
                    inst.h--;
                }
                if alarm[1]=-1 {
                     alarm[1]=30;
                }
            }               

    }
    else {
        if current_path="path_wall"  {
            pos1=path_get_closest_point(x,y,grouppath,obj_solid,global.grid);
            x1=path_get_point_x(grouppath,pos1);
            y1=path_get_point_y(grouppath,pos1);
            if path_exists(path_wall) {
            path_delete(path_wall);   
            }
            if grid!=-1 {
                mp_grid_destroy(grid)
                grid=-1;
            }
            mp_grid_path(global.grid,mypath,x,y,x1,y1,true);
            pos2=1;
            x2=path_get_point_x(mypath,pos2); //This gets the x/y coords of the next point on the short path
            y2=path_get_point_y(mypath,pos2);
            current_path="grouppath"
        }
    }
}
if collision_circle(xxx,yyy,5,obj_crystal,false,true) {
    path_end();
    if path_exists(finalpath) {
        path_delete(finalpath)
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="obj_sword">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Die
if h&gt;50 {
    h=-50;
}
else {
    h=0;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints>
    <point>16,16</point>
    <point>16,16</point>
  </PhysicsShapePoints>
</object>
