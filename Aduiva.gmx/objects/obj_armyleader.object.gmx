<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_minion1_down</spriteName>
  <solid>-1</solid>
  <visible>-1</visible>
  <depth>-1</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Sprite arrays
level=1
rot=true;
minion[0] = spr_minion1_right;
minion[1] = spr_minion1_right_up;
minion[2] = spr_minion1_down;
minion[3] = spr_minion1_left_up;
minion[4] = spr_minion1_left;
minion[5] = spr_minion1_left;
minion[6] = spr_minion1_left_down
minion[7] = spr_minion1_up;

miniona[0] = spr_minion1_attack_right;
miniona[1] = spr_minion1_attack_right_up;
miniona[2] = spr_minion1_attack_down;
miniona[3] = spr_minion1_attack_left_up;
miniona[4] = spr_minion1_attack_left;
miniona[5] = spr_minion1_attack_left;
miniona[6] = spr_minion1_attack_left_down
miniona[7] = spr_minion1_attack_up;


</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Create grid, path, and variables
selected=false;    //is the player selected 
xx=0;             //variable used for x/y cordinates
yy=0;
sx=0;
sy=0;
global.cnt=0;
groupsize=0;
global.moveselected=0;
ddx=0;
ddy=0;
attack=false;
grouppath=path_add();
mypath=path_add();
dx=global.dx;
dy=global.dy;
mp_grid_path(global.grid,grouppath,x,y,dx,dy,1);  //make a new path from the closest cordinates on current path to the new destination
attackpath=path_add();            
pos1=1; //This holds the next point on the global path to move to...
x1=path_get_point_x(grouppath,pos1); //This gets the x/y coords of the next point...
y1=path_get_point_y(grouppath,pos1);
mp_grid_path(global.grid,mypath,x,y,x1,y1,true); //Create the short path...
pos2=1;
x2=path_get_point_x(mypath,pos2); //This gets the x/y coords of the next point on the short path...
y2=path_get_point_y(mypath,pos2);
grid=-1;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Delete path
if path_exists(mypath) {
    path_delete(mypath);
    
}
if path_exists(grouppath) {
    path_delete(grouppath);

}
if path_exists(attackpath) {
    path_delete(attackpath);

}
if grid=-1 {
    mp_grid_destroy(grid);

}


</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Allow sprite rotate
rot=true;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Sprites, attacking, dieing
  var xxx, yyy;
  xxx = x + lengthdir_x(10, direction);
  yyy = y + lengthdir_y(10, direction);
            
if  collision_circle(x,y,10,obj_enemy,0,0) {
    path_position=path_positionprevious;
       var op
       op=instance_nearest(x,y,obj_enemy);
       with (op) {
       h--;
       }
       sprite_index=miniona[round(direction / 45) mod 8];
       image_speed=0.5;
}
else {
    if rot=true {
        sprite_index=minion[round(direction / 45) mod 8];
    }
    else sprite_index=sprite_index;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Pathfinding
                               //is active
    if path_exists(grouppath) &amp;&amp; attack=false {          //if a destination exists
    

//First check to see where on the global path we are and move the point foward if necessary
        if point_distance(x,y,x1,y1)&lt;12 {
            pos1+=1;
            if pos1=path_get_number(grouppath) {
                    path_delete(grouppath);
                    path_end();
                    image_speed=0;
                    }
                
            
            else {
             //The enemy hasn't reached the end so we calculate the x/y coords
             //of the next point on the group path
                    x1=path_get_point_x(grouppath,pos1);
                    y1=path_get_point_y(grouppath,pos1);
            }
        }

            //Now we will deal with the short path
            if point_distance(x,y,x2,y2)&lt;12 {
                //If you are close, advance one point on the path
                pos2+=1;
                if pos2=path_get_number(mypath) {
                    //If we are at the path end, create a new short
                    //path to the next point on the group path
                    mp_grid_path(global.grid,mypath,x,y,x1,y1,true);
                    pos2=1;
                    x2=path_get_point_x(mypath,pos2); //This gets the x/y coords of the next point on the short path
                    y2=path_get_point_y(mypath,pos2);
                    path_set_kind(mypath,1); //Sets the path to allow diagonals
                    path_set_precision(mypath,8); //Sets the path to curve
                }
            }


//Now use mp_potential_step to move along the path from point to point
            var xxx, yyy;
            xxx = x + lengthdir_x(10, direction);
            yyy = y + lengthdir_y(10, direction);
            
            if collision_circle(xxx,yyy,10,obj_armyleader,false,true) {
                if path_exists(grouppath){
                path_position=path_positionprevious;
                direction+=10;
                rot=false;
                image_speed=0;
                }
               
            }
            
            
            else {
                if rot=false {
                    alarm[2]=30;
                }
                mp_potential_step(x2,y2,1,false);
                if path_exists(grouppath) {
                    image_speed=1;
                }
            }
}
   
        
var arc;
if attack=false {
arc=arc_of_sight(x,y,direction,200,90,obj_enemy,obj_solid);
}
else {
arc=arc_of_sight(x,y,direction,200,160,obj_enemy,obj_solid);
}
if arc=noone {
        if attack=true {
            if path_position=1 || !path_exists(attackpath) {
            attack=false;
            var pos,posx,posy;
            if path_get_nearest_pos(grouppath,x,y)!=noone {
            pos=path_get_nearest_pos(grouppath,x,y);
            posx=path_get_x(grouppath,pos);
            posy=path_get_y(grouppath,pos);
            if mp_grid_path(global.grid,mypath,x,y,posx,posy,true) {
            mp_grid_path(global.grid,mypath,x,y,posx,posy,true);
            }
            pos2=1;
            x2=path_get_point_x(mypath,pos2); //This gets the x/y coords of the next point on the short path
            y2=path_get_point_y(mypath,pos2);
            }
            if path_exists(attackpath) {
            path_delete(attackpath);   
            }
            if !instance_place(dx,dy,obj_waypoint) {
            instance_create(dx,dy,obj_waypoint);
            global.marker=true;
            }
            }
        }
        }
            
    
    else {
    attack=true;
    var wx,wy,way;
    wx=path_get_x(grouppath,1);
    wy=path_get_y(grouppath,1);
    way=instance_nearest(wx,wy,obj_waypoint) 
    if point_distance(way.x,way.y,wx,wy)&lt;12 {
        with (way) {
        instance_destroy();
        }
    }
    ddx=arc.x;
    ddy=arc.y;
    var xxx, yyy;
    xxx = x + lengthdir_x(10, direction);
    yyy = y + lengthdir_y(10, direction);
    
    if !path_exists(attackpath) {
        attackpath=path_add();
    }
    if grid=-1 {
    grid=mp_grid_create(0,0,room_width/16,room_height/16,16,16); //create grid
    sx=x;
    sy=y;
    }
    else { 
     var near;
     near=instance_nth_nearest(x,y,obj_armyleader,2);
     mp_grid_add_instances(grid,near,1);
     mp_grid_add_instances(grid,obj_solid,1);
     }
    if collision_circle(xxx,yyy,10,obj_armyleader,false,true) || collision_circle(xxx,yyy,10,obj_enemy,false,true) {
        path_position=path_positionprevious;
        image_speed=0;
    }
    else {
     if mp_grid_path(grid,attackpath,x,y,ddx,ddy,1) {
        direction=point_direction(x,y,ddx,ddy);
        mp_grid_path(grid,attackpath,x,y,ddx,ddy,1);
        path_start(attackpath,1.5,"",1);
        image_speed=1;
        }
  }
     
  
    }

    

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="6" enumb="57">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Unselect
selected=false;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="6" enumb="56">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Select the unit

if((x &gt; obj_mouse.clickx &amp;&amp; x &lt; mouse_x &amp;&amp; y &lt; obj_mouse.clicky &amp;&amp; y &gt; mouse_y) || (x &gt; obj_mouse.clickx &amp;&amp; x &lt; mouse_x &amp;&amp; y &gt; obj_mouse.clicky &amp;&amp; y &lt; mouse_y) || (x &lt; obj_mouse.clickx &amp;&amp; x &gt; mouse_x &amp;&amp; y &lt; obj_mouse.clicky &amp;&amp; y &gt; mouse_y) || (x &lt; obj_mouse.clickx &amp;&amp; x &gt; mouse_x &amp;&amp; y &gt; obj_mouse.clicky &amp;&amp; y &lt; mouse_y)) {    //is object inside selection rectangle?
    global.cnt++;
    selected = true;    
    global.marker=true;   //draw the marker
          //if not active
         //add the count                                                         
    }
    
else {
    selected=false;       //do not select if not inside the rectangle                                                                   
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="6" enumb="54">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Right click to direct the selected unit
var n, num, inst;   
num = instance_number(obj_armyleader);                  
for (n=1; n&lt;=num; n++) {
    inst = instance_nth_nearest(dx,dy,obj_armyleader,n);
        if (inst.selected==true) {
            break;
            }
}
                    
dx = mouse_x;                      //set destination cordinates
dy = mouse_y; 
if attack=true {
attack=false
direction=point_direction(x,y,dx,dy);
}
if !collision_point(mouse_x,mouse_y,obj_solid,1,1) {           
if obj_mouse.inside_view=2 {                //if you click inside the commander's view
    if (selected==true) { 
                       //if the minion is selected
    
                    
                                                            //if the minion is already active
            var xx,yy;
            if path_exists(grouppath){
                global.moveselected++;
                xx=path_get_x(grouppath,1);
                yy=path_get_y(grouppath,1);
                if global.moveselected&gt;=groupsize {
                    with instance_nearest(xx,yy,obj_waypoint) {
                        instance_destroy();
                    }
                }
            }
            else {
                    grouppath=path_add();
                    mypath=path_add();
            } 
            if mp_grid_path(global.grid,grouppath,inst.x,inst.y,dx,dy,1) {  
            mp_grid_path(global.grid,grouppath,inst.x,inst.y,dx,dy,1);  //make a new path from the closest cordinates on current path to the new destination
                global.marker=true;
                    pos1=1; //This holds the next point on the global path to move to...
                    x1=path_get_point_x(grouppath,pos1); //This gets the x/y coords of the next point...
                    y1=path_get_point_y(grouppath,pos1);
                    mp_grid_path(global.grid,mypath,x,y,x1,y1,true); //Create the short path...
                    pos2=1;
                    x2=path_get_point_x(mypath,pos2); //This gets the x/y coords of the next point on the short path...
                    y2=path_get_point_y(mypath,pos2);
                    
               
                 
                
    groupsize=global.cnt;
         }
         else  {
        global.marker=false;
        }
         
    }
    
}
}
else {
global.marker=false;
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="6" enumb="53">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Reset selected minion count
global.cnt=0;
global.moveselected=0;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Draw gui, selection rectangle, paths

if (selected==true) { //if minion is selected
    if view_current==2 {    //only on commmanders view
            draw_sprite_ext(sprite_index,image_index,x,y,image_xscale, image_yscale, image_angle,c_red,1);
        }
    }
else {
draw_self();
}

             
if path_exists(grouppath)  {
    draw_set_colour(c_white);             //draw the minion's path
    draw_path(grouppath,x,y,true);
}

            
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints>
    <point>16,16</point>
    <point>16,16</point>
  </PhysicsShapePoints>
</object>
