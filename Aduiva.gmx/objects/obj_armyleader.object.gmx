<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_minion1_down</spriteName>
  <solid>-1</solid>
  <visible>-1</visible>
  <depth>-1</depth>
  <persistent>0</persistent>
  <parentName>obj_enemy_parent</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Sprite arrays
global.diesprite=noone;
level=1
rot=true;
minion[0] = spr_minion1_right;
minion[1] = spr_minion1_right_up;
minion[2] = spr_minion1_up;
minion[3] = spr_minion1_left_up;
minion[4] = spr_minion1_left;
minion[5] = spr_minion1_left_down
minion[6] = spr_minion1_down;
minion[7] = spr_minion1_right_down;

miniona[0] = spr_minion1_attack_right;
miniona[1] = spr_minion1_attack_right_up;
miniona[2] = spr_minion1_attack_up;
miniona[3] = spr_minion1_attack_left_up;
miniona[4] = spr_minion1_attack_left;
miniona[5] = spr_minion1_attack_left_down;
miniona[6] = spr_minion1_attack_down;
miniona[7] = spr_minion1_attack_right_down;

miniond[0] = spr_minion1_die_right;
miniond[1] = spr_minion1_die_right_up;
miniond[2] = spr_minion1_die_up;
miniond[3] = spr_minion1_die_left_up;
miniond[4] = spr_minion1_die_left;
miniond[5] = spr_minion1_die_left_down;
miniond[6] = spr_minion1_die_down;
miniond[7] = spr_minion1_die_right_down;


</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Create grid, path, and variables
h=100;
selected=false;    //is the player selected 
xx=0;             //variable used for x/y cordinates
yy=0;
sx=0;
sy=0;
global.cnt=0;
groupsize=0;
global.moveselected=0;
ddx=0;
ddy=0;
attack=false;
grouppath=path_add();
mypath=path_add();
dx=global.dx;
dy=global.dy;
mp_grid_path(global.grid,grouppath,x,y,dx,dy,1);  //make a new path from the closest cordinates on current path to the new destination
attackpath=path_add();            
pos1=1; //This holds the next point on the global path to move to...
x1=path_get_point_x(grouppath,pos1); //This gets the x/y coords of the next point...
y1=path_get_point_y(grouppath,pos1);
mp_grid_path(global.grid,mypath,x,y,x1,y1,true); //Create the short path...
pos2=1;
x2=path_get_point_x(mypath,pos2); //This gets the x/y coords of the next point on the short path...
y2=path_get_point_y(mypath,pos2);
grid=-1;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Delete path
global.diesprite=sprite_index;
instance_create(x,y,obj_soul);

if path_exists(mypath) {
    path_delete(mypath);
    
}
if path_exists(grouppath) {
    path_delete(grouppath);

}
if path_exists(attackpath) {
    path_delete(attackpath);

}
if grid=-1 {
    mp_grid_destroy(grid);

}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="3">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Die
instance_destroy();
global.diesprite=sprite_index;
instance_create(x,y,obj_soul);

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Allow sprite rotate
rot=true;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Sprites, attacking, dieing
  var xxx, yyy;
  xxx = x + lengthdir_x(10, direction);
  yyy = y + lengthdir_y(10, direction);
            
if  collision_circle(x,y,20,obj_enemy,0,0) {
    path_position=path_positionprevious;
    path_end();
    if path_exists(attackpath) {
        path_delete(attackpath)
    }
       var op
       op=instance_nearest(x,y,obj_enemy);
       direction=point_direction(x,y,op.x,op.y);
       if op.h&gt;0 {
       op.h--;
       }
       sprite_index=miniona[round(direction / 45) mod 8];
       image_speed=0.2;
}

else {
    if rot=true {
        sprite_index=minion[round(direction / 45) mod 8];
        image_speed=0.5;
    }
    else {
        image_speed=0;
    }

}

if h=0 {
    sprite_index=miniond[round(direction / 45) mod 8];
    image_speed=0.1;
    attack=false;
    if image_index&gt;image_number-1 {
        instance_destroy();
    }
}


</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Pathfinding
move_outside_solid(direction,speed);                               //is active
if path_exists(grouppath) &amp;&amp; attack=false {          //if a destination exists
//First check to see where on the global path we are and move the point foward if necessary
        if point_distance(x,y,x1,y1)&lt;12 {
            pos1+=1;
            if pos1=path_get_number(grouppath) {
                    path_end();
                    path_delete(grouppath);
                    rot=false;
                    }
                
            
            else {
             //The enemy hasn't reached the end so we calculate the x/y coords
             //of the next point on the group path
                    x1=path_get_point_x(grouppath,pos1);
                    y1=path_get_point_y(grouppath,pos1);
            }
        }

            //Now we will deal with the short path
            if point_distance(x,y,x2,y2)&lt;12 {
                //If you are close, advance one point on the path
                pos2+=1;
                if pos2=path_get_number(mypath) {
                    //If we are at the path end, create a new short
                    //path to the next point on the group path
                    mp_grid_path(global.grid,mypath,x,y,x1,y1,true);
                    pos2=1;
                    x2=path_get_point_x(mypath,pos2); //This gets the x/y coords of the next point on the short path
                    y2=path_get_point_y(mypath,pos2);
                    path_set_kind(mypath,1); //Sets the path to allow diagonals
                    path_set_precision(mypath,8); //Sets the path to curve
                }
            }


//Now use mp_potential_step to move along the path from point to point
            var xxx, yyy;
            xxx = x + lengthdir_x(5, direction);
            yyy = y + lengthdir_y(5, direction);
            
            if collision_circle(xxx,yyy,5,obj_armyleader,false,true) {
                if path_exists(grouppath){
                path_position=path_positionprevious;
                direction+=10;
                rot=false;
                image_speed=0;
                }
               
            }
            
            else if place_meeting(x,y,obj_solid) {
                move_outside_solid(direction,speed);
            }
            
            
            else {
                if rot=false {
                    rot=true;
                }
                mp_potential_step(x2,y2,1,false);
                if path_exists(grouppath) {
                    image_speed=1;
                }
            }
}
      
var arc;
if attack=false {
arc=arc_of_sight(x,y,direction,200,90,obj_enemy,obj_solid);
}
else {
arc=arc_of_sight(x,y,direction,200,160,obj_enemy,obj_solid);
}
if arc=noone {
    if place_meeting(x,y,obj_solid) {
                move_outside_solid(direction,speed);
            }
        if attack=true {
            pos1=path_get_closest_point(x,y,grouppath,obj_solid,global.grid);
            x1=path_get_point_x(grouppath,pos1);
            y1=path_get_point_y(grouppath,pos1);
            if path_exists(attackpath) {
            path_delete(attackpath);   
            }
            if grid!=-1 {
                mp_grid_destroy(grid)
                grid=-1;
            }
            mp_grid_path(global.grid,mypath,x,y,x1,y1,true);
            pos2=1;
            x2=path_get_point_x(mypath,pos2); //This gets the x/y coords of the next point on the short path
            y2=path_get_point_y(mypath,pos2);
            if !instance_place(dx,dy,obj_waypoint) {
            instance_create(dx,dy,obj_waypoint);
            global.marker=true;
            attack=false;
            }
        }
}
            
    
    else {
    attack=true;
    var wx,wy,way;
    wx=path_get_x(grouppath,1);
    wy=path_get_y(grouppath,1);
    way=instance_nearest(wx,wy,obj_waypoint) 
    if point_distance(way.x,way.y,wx,wy)&lt;12 {
        with (way) {
        instance_destroy();
        }
    }
    ddx=arc.x;
    ddy=arc.y;
    var xxx, yyy;
    xxx = x + lengthdir_x(10, direction);
    yyy = y + lengthdir_y(10, direction);
    if grid=-1 {
    grid=mp_grid_create(0,0,room_width/16,room_height/16,16,16); //create grid
    }
    else { 
    mp_grid_clear_all(grid);
    mp_grid_add_instances(grid,obj_solid,1);
     var near1, near2, near3;
     near1=instance_nth_nearest(x,y,obj_armyleader,2);
     mp_grid_add_instances(grid,near1,1);
     mp_grid_add_instances(grid,obj_wall,1);
    if !collision_circle(x,y,20,obj_enemy,1,1)  {
    if !path_exists(attackpath) {
        attackpath=path_add();
    }
        direction=point_direction(x,y,ddx,ddy);
        mp_grid_path(grid,attackpath,x,y,ddx,ddy,1);
        path_start(attackpath,1.5,"",1);
        image_speed=1;
        rot=true;
        }
}
  
}

    

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="obj_solid">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string></string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="6" enumb="57">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Unselect
selected=false;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="6" enumb="56">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Select the unit

if((x &gt; obj_mouse.clickx &amp;&amp; x &lt; mouse_x &amp;&amp; y &lt; obj_mouse.clicky &amp;&amp; y &gt; mouse_y) || (x &gt; obj_mouse.clickx &amp;&amp; x &lt; mouse_x &amp;&amp; y &gt; obj_mouse.clicky &amp;&amp; y &lt; mouse_y) || (x &lt; obj_mouse.clickx &amp;&amp; x &gt; mouse_x &amp;&amp; y &lt; obj_mouse.clicky &amp;&amp; y &gt; mouse_y) || (x &lt; obj_mouse.clickx &amp;&amp; x &gt; mouse_x &amp;&amp; y &gt; obj_mouse.clicky &amp;&amp; y &lt; mouse_y)) {    //is object inside selection rectangle?
    global.cnt++;
    selected = true;    
    global.marker=true;   //draw the marker
          //if not active
         //add the count                                                         
    }
    
else {
    selected=false;       //do not select if not inside the rectangle                                                                   
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="6" enumb="54">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Right click to direct the selected unit
var n, num, inst;   
num = instance_number(obj_armyleader);                  
for (n=1; n&lt;=num; n++) {
    inst = instance_nth_nearest(dx,dy,obj_armyleader,n);
        if (inst.selected==true) {
            break;
            }
}
rot=true                    
dx = mouse_x;                      //set destination cordinates
dy = mouse_y; 
if attack=true {
attack=false
direction=point_direction(x,y,dx,dy);
}
if !collision_point(mouse_x,mouse_y,obj_solid,1,1) {           
if obj_mouse.inside_view=2 {                //if you click inside the commander's view
    if (selected==true) { 
                       //if the minion is selected
    
                    
                                                            //if the minion is already active
            var xx,yy;
            if path_exists(grouppath){
                global.moveselected++;
                xx=path_get_x(grouppath,1);
                yy=path_get_y(grouppath,1);
                if global.moveselected&gt;=groupsize {
                    with instance_nearest(xx,yy,obj_waypoint) {
                        instance_destroy();
                    }
                }
            }
            else {
                    grouppath=path_add();
                    mypath=path_add();
            } 
            if mp_grid_path(global.grid,grouppath,inst.x,inst.y,dx,dy,1) {  
            mp_grid_path(global.grid,grouppath,inst.x,inst.y,dx,dy,1);  //make a new path from the closest cordinates on current path to the new destination
                global.marker=true;
                    pos1=1; //This holds the next point on the global path to move to...
                    x1=path_get_point_x(grouppath,pos1); //This gets the x/y coords of the next point...
                    y1=path_get_point_y(grouppath,pos1);
                    mp_grid_path(global.grid,mypath,x,y,x1,y1,true); //Create the short path...
                    pos2=1;
                    x2=path_get_point_x(mypath,pos2); //This gets the x/y coords of the next point on the short path...
                    y2=path_get_point_y(mypath,pos2);
                    
               
                 
                
    groupsize=global.cnt;
         }
         else  {
        global.marker=false;
        }
         
    }
    
}
}
else {
global.marker=false;
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="6" enumb="53">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Reset selected minion count
global.cnt=0;
global.moveselected=0;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Move around wall
if path_exists(grouppath) {
    if attack=false {
        path_end();
        if !mp_grid_path(global.grid,grouppath,x,y,dx,dy,true) //Checks to see if the new path is possible...
        {
    //Now we are going to draw an imaginary line
    //between each of the points on the path and see
    //if the line collides with a wall object. If it does
    //the we remove the wall from the room and the mp_grid
    //then go back and re-calculate the path...
    var num,p,x1,y1,x2,y2,i,inst; //Temp variables...
    num=path_get_number(grouppath); //Get the number of points on the path...
    for (i=1; i&lt;num; i+=1;) //this is to loop through the points...
        {
        x1=path_get_point_x(grouppath,i-1); //Get the x/y coords of two points...
        y1=path_get_point_y(grouppath,i-1);
        x2=path_get_point_x(grouppath,i);
        y2=path_get_point_y(grouppath,i);
        inst=collision_line(x1,y1,x2,y2,obj_wall,true,true); //Check for a collision with parent object...
        if inst!=noone
            {
            with (inst) //Destroy the colliding wall and remove it from the grid...
                {
                //You will need to change this to suit the size of the grid you use!!!!
                mp_grid_clear_rectangle(global.grid, x-sprite_xoffset, y-sprite_yoffset, x+sprite_xoffset, y+sprite_yoffset); //Clears the AI grid before destroying itself...
                instance_destroy();
                }
            show_message("You are blocking your minions"); //Tells us not to place a wall...
            event_user(0); //re-run the event again to re-calculate the new path...
            break;
            }
        }
    }
    else
    {
    mp_grid_path(global.grid,grouppath,x,y,dx,dy,true); //Assigns the new path...
    path_set_kind(grouppath,1); //Sets the path to allow diagonals...
    path_set_precision(grouppath,8); //Sets the path to curve...
    }
}
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="7">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if h=0 { 
    instance_destroy();
    }
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Draw gui, selection rectangle, paths

if (selected==true) { //if minion is selected
    if view_current==2 {    //only on commmanders view
            draw_sprite_ext(sprite_index,image_index,x,y,image_xscale, image_yscale, image_angle,c_red,1);
        }
              else {
            draw_self();
        }
    }
else {
draw_self();
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints>
    <point>16,16</point>
    <point>16,16</point>
  </PhysicsShapePoints>
</object>
